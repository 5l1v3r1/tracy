\documentclass[a4paper]{article}

\author{Jurriaan Bremer \and Merlijn Wajer \and Bas Weelinck}
\title{Soxy: Transparent SOCKS proxy using Tracy}

\usepackage{hyperref}
\usepackage[utf8]{inputenc}

\begin{document}
\maketitle

\section{Soxy: Transparent SOCKS proxy using Tracy}

\subsection{Proxies}
In computer science, a \textbf{proxy} is an intermediate server that
accepts connections from a host and forwards them to another host,
therefore giving the sending host more privacy (that is, the
receiving host gets the IP address from the intermediate server).
Software can use a proxy server knowingly or unknowingly.

An application can be configured to connect through a proxy. For example, in
the popular web browser Firefox it is possible to specify how Firefox connects
to the internet, and one can directly tell Firefox how to do so.
It is possible to tell Firefox which credentials to use for which type of proxy,
if any at all.

In this case, the software explicitly has to implement functionality to use a
proxy. It is also possible to have software use a proxy even if it hasn't
implemented specific proxy functionality: by making the usage of a proxy
completely \textit{transparent} to the software.

By transparent we mean that the software unknowingly
\footnote{And perhaps even unwillingly} uses a proxy. Tools that achieve this
are called \textit{proxifiers}.
\footnote{https://en.wikipedia.org/wiki/Comparison\_of\_proxifiers}
Soxy is a proxyfier.

\subsubsection{Intercepting calls}

To transparently have a program use a proxy, a proxy program like \textbf{Soxy}
has to intercept and modify the \textit{socket} function calls.

There are again several ways of intercepting and/or changing the socket function
calls.

A popular implementation of a transparent SOCKS 5 proxy \textbf{tsocks}
\footnote{We believe \textbf{torsocks} does something similar}
utilises the \textit{LD\_PRELOAD} feature on POSIX-compatible systems to
intercept the socket function calls and replace them with its own.

We propose using the POSIX \textbf{ptrace} feature to transparently have
software use a proxy. \textit{Tracy}, will make use of this POSIX feature and
provide an easy to use API to intercept and modify system calls to Soxy.

\subsection{SOCKS 5}

SOCKet Secure (SOCKS) is an Internet protocol that routes TCP-connections and
UDP packets between a client and server through a proxy server. SOCKS5
additionally provides authentication so only authorized users may access a
server. It doesn't implement TCP on top of TCP but instead allows the computer using
the proxy to issue TCP connections from the proxy server or open (UDP) ports on the
proxy server.
\footnote{https://en.wikipedia.org/wiki/SOCKS}
\footnote{https://tools.ietf.org/html/rfc1928}

\subsection{ptrace}

\textbf{ptrace(2)} is a system call which provides a means to observe and
control the execution of another process by intercepting (all) the system calls
of said process.

This way it is possible to intercept \textbf{specific} system calls related to
networking. In theory, one could turn the data being send by the software into
proper SOCKS 5 packets and relay those packets to the proxy server. The same
could be done for incoming data (namely: extract the data from the SOCKS 5
packets and pass it to the software).

An additional advantage of using \textbf{ptrace} is that ptrace also allows
attaching to a running process in which case we could have a program
transparently start using our proxy without having to restart said program. This
does raise some serious complications, but theoretically it is possible.

\subsection{Features, limitations and goals}

\subsubsection{Tracy}
To create \textbf{Soxy} we will first write a ptrace helper library called
\textbf{Tracy}, which will ease the usage of ptrace in soxy itself.
We hope to create a feature-rich helper library that can be re-used in
other projects as well. The main features of this helper library will be:

\begin{itemize}
\item Support for several platforms. We will start with ARM, x86 and amd64, but
do not exclude the possibility that we will add support for more architectures
later.

\item Allowing processes to easily hook into system calls. This includes:
    \begin{itemize}
    \item Reading and modifying registers, including the system call number
    register, registers that contain system call arguments and the instruction
    pointer register.
    \item 
    \end{itemize}

\item Reading and modifying the memory of the child.

\item Support for system call injection. This is required to efficiently
access the memory of the child.

\item A mechanism to modify system calls. This will allow the client to
either deny or completely change system calls.
\end{itemize}

\subsubsection{Soxy}
Once \textbf{tracy} is functional, we will strive to implement the following
features in \textbf{soxy}:

\begin{itemize}
\item Support for TCP. (blocking and non-blocking)
\item Support for IPv4.
\item Support for rule-based proxies. For example, do not use a proxy for
host \textbf{foo} with port \textbf{bar}.
\end{itemize}

If time permits us, we will also implement:

\begin{itemize}
\item Support for IPv6.
\item Support for UDP.
\end{itemize}

In addition to these features, we will focus on maintainability, readability
and features of the implementation, rather than efficiency and speed.
Typically proxies are not doing much more than wrapping data in frames and
relaying them to the proxy server, and the speed of a proxy depends mostly
on the speed on the network the machine is using and not on the speed of
the CPU.

We will also keep the code well documented and create a \textbf{man} page. \\

We will not focus on attaching to a running program and then have it use our
proxy functions. % kut zin
Instead, a program that will use the transparent proxy has to be started by our
proxy implementation by passing it as an argument to said proxy. For example:

\begin{verbatim}
soxy -v -- firefox -private
\end{verbatim}

Will run the program (Firefox) with the additional argument ''-private''.

\end{document}
