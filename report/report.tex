\documentclass[a4paper, twoside, 10pt, twocolumn]{report}

\author{Jurriaan Bremer \and Merlijn Wajer \and Bas Weelinck}
\title{Tracy: UNIX system call tracing}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}

\begin{document}
\maketitle

\nocite{*}
\bibliographystyle{plain}

\begin{abstract}
    Tracy is a system call tracing framework implemented on top of the UNIX
    ptrace(2) system call.
    Tracy can trace, modify and inject system calls as well as perform memory
    allocation in the child, modifying the memory of children and safely trace
    all (newly created) children of a process being traced.
\end{abstract}

\tableofcontents

% Probleemstelling / Motivatie
% Wat is er al?
% Hoe? Oplossing
% Implementatie / Toepassing / Illustratie
% Conclusie
% Referenties / Further Work
%
% XXX NOTES XXX
%
% PTRACE_TRACE_{FORK,VFORK,CLONE} is a mess. If we simply want to be called on
% clone() in case of a clone event, we must disable fork and vfork; otherwise it
% may also instead return fork or vfork events. From the man page:
%
% This  option  may not catch clone(2) calls in all cases.  If the tracee calls clone(2)
% with  the  CLONE_VFORK  flag,  PTRACE_EVENT_VFORK  will  be   delivered   instead   if
% PTRACE_O_TRACEVFORK  is set; otherwise if the tracee calls clone(2) with the exit sig‚Äê
% nal set to SIGCHLD, PTRACE_EVENT_FORK will be delivered if PTRACE_O_TRACEFORK is set.

% Gebruiken PTRACE_O_TRACESYSGOOD voor performance.

% execve(2) under ptrace:
% When one thread in a multithreaded process calls execve(2), the kernel destroys all other threads in
% the  process,  and  resets  the thread ID of the execing thread to the thread group ID (process ID).
% (Or, to put things another way, when a multithreaded process does an execve(2), at completion of the
% call,  it  appears  as though the execve(2) occurred in the thread group leader, regardless of which
% thread did the execve(2).)  This resetting of the thread ID looks very confusing to tracers:


% XXX END NOTES XXX

%
% ---- STUFF -----
% socketcall
% KISS
% Add SOCKS5 somewhere. (Probably related work)
% UDP in the current SOCKS5 protocol
% UDP over ssh ( :-( )
% sshfs ergens noemen?
% ---- STUFF -----

\chapter{Motivation}

When analysing or debugging programs it is customary to trace system calls made
a process. This often provides a useful insight in what the program is doing and
possibly what it is doing wrong.

When tracing a process $A$, another process $B$ is notified when a system call
is made by process $A$  and then allows process $A$ to continue with its
execution. An example of a program that traces system calls is
\textit{strace}\cite{strace}.

Apart from just tracing system calls, it is also possible to change
(arguments of) system calls before they are executed. This allows for a range
of other applications such as not allowing specific system calls, denying
specific system calls, injecting system calls. Typically, the debugging api also
allows reading and writing to the process being debugged.

Some of the applications that can be realised with this particular feature set
including jailing programs, performance analysis tools and transparently
redirecting input and output of a program, such as proxifying network
traffic or virtualising filesystem access.

The debugger API on most UNIX operating systems is done using the
\textit{ptrace} system call. A huge downside of ptrace is has not been
standarised and differs per platform and computer architecture. Other
shortcomings of ptrace will be discussed later on.
% FIXME WHERE ^

One of the main reasons we created Tracy was the lack of a proper library
for system call interception amongst the popular UNIX systems with
varying CPU architectures.

Tracy is a process tracing framework which uses ptrace but tries to have an API
that is mostly platform and computer architecture independent, allowing for much
easier creation of tracing applications. While it is not possible to create a
completely platform independent API while not heavily reducing functionality, we
strive to create a robust and powerful API to trace processes in a more platform
independent way.

To demonstrate the system call interception, injection and modification
we introduce Soxy\ref{chapter:soxy}: an application to route network
traffic through a SOCKS 5 proxy using Tracy.

% Oplossing voor problemen zoals:
%   -   Jailing/Sandboxing
%   -   Debugging tools
%   -   Performance analysis tools
%   -   Transparent routing of lots of different things. (fuse in only userspace
%   for example, vpn, socks proxy)
%
%   Bestaande tools:
%   -   GDB, Valgrind
%   -   strace
%   -   tsocks (maar limited)

% Tracy can be used to create a wide variety of software, including
% \textit{Debugging tools}, \textit{Performance analysis tools}, \textit{Forensic
% tools}, \textit{Jailing and Sandboxing tools} and \textit{Transparent routing of
% data} (such as internet packets of user space filesystems).


% Hopelijk is dit iets meer wat Leen bedoelt. Wat secties hier onder moeten we
% omschrijven. Een beetje dubbel op informatie is geen probleem, daarvoor is het
% een inleiding.
% LD_PRELOAD is niet zo boeiend.
%

\section{Existing solutions and their problems}

% TODO: Text here
% Uitleggen dat er flawed oplossingen zijn, e.d. Hoeft nog niet in detail.

\subsection{LD\_PRELOAD}

\textbf{LD\_PRELOAD} is a way to prioritize loading of certain libraries
while creating and loading a process.

One can use this to load a shared object (a library) into a process,
before any other libraries (such as glibc) are loaded;
this makes it possible to override functions typically provided by other
libraries.

(For our example, this ``injected'' library would provide its own
``recvfrom'' and ``sendto''\footnote{It should probably provide
a lot more functions; but the example will not benefit from naming others.};
and the program being run
would instead call the functions provided by this library.) One common
proxyfier, \textbf{tsocks}, has an application that loads other applications
with their own library that overwrites specific network functionality,
thus allowing transparent network routing.

However, because LD\_PRELOAD relies on the dynamic loader and the fact that
programs have to make use of libraries, it also has several downsides.

One of these downsides is that LD\_PRELOAD simply doesn't work on all
applications; some applications do not use the glibc methods and instead
perform system calls directly. Another way to ``escape'' from LD\_PRELOAD
is indeed to simply perform system calls in the program (using inline assembly
or even the \textit{syscall(2)} system call) rather than using
provided libraries such as glibc.

There are some upcoming languages that do not even use glibc at all - languages
like Go \footnote{\url{http://golang.org/}} talk to the kernel directly and
thus perform their own system calls.

LD\_PRELOAD is not a viable solution if one wants to transparently capture all
(specific) system calls of a process, independent on what kind of userspace
libraries the process uses.

\subsection{The ptrace(2) API}

\textbf{ptrace(2)} allows a process to catch all of the system calls (or even
step through every instruction, but we have no use for that in tracy)
made by another process (called the \textit{tracee}), which makes it
completely independent of user space helper libraries used by the tracee.
In other words, ptrace does not suffer from the same problem as LD\_PRELOAD.

ptrace has platform-specific extensions (to the API) and the
implementation differs per platform. % FIXME: Wat voor extensions?

% Beetje vreemd, want we willen wel alle system calls afvangen
To actually catch every single system call made by a process one has to
perform all sorts of tricks\ref{foo}, depending on the operating system and
architecture. Tracy currently does not implement all of these tricks, but
support is planned.
 % TODO all kinds of tricks, link to caveats section in our paper.

Aside from functional differences, there are also different ptrace options.
For example, BSD supports reading or writing a big chuck of the memory
of the tracee at once, while Linux only allows reading or writing only one
word at a time. On the other hand, Linux has options to automatically trace
children created by the tracee where BSD lacks support for
this particular feature\footnote{Tracy will however support it on BSD}.
% TODO reference to solution ^

Aside from the differences per operating system, there are also differences
regarding the cpu architecture, because every architecture has it's own
instruction set.

Due to ptrace being a very low-level system call, which operates on assembly
level, it is not possible to simply ``change the return value'' of a system
call. Each instruction set has its own registers and on top of that, operating
systems often have different uses for each register.


% Dit is niet te veel detail, het is een realisatie van echte ptrace problemen
% en een goede inleiding naar de volgende alineas - namelijk dat ptrace niet
% geschikt is om direct te gebruiken en dat tracy veel beter is.
One would have to find out what register this is on each platform,
keep track if the current event is a pre- or post-system call event, let alone
perform some extra architecture-specific calls to ensure that the result is
properly set\footnote{ARM requires extra changes to make the register
modification of a system call number persistent.}.

There is no way to hook into a specific system call, no way
to simply inject a system call, it is not simple to change values of some
variable/register in an architecture-agnostic way and it is not trivial
to allocate memory in a child.

Even though ptrace(2) provides all the functionality required to trace and
intercept system calls\footnote{Which is why Tracy uses ptrace},
the functions provided by ptrace are very basic and only provide the
essential building blocks for tracing applications.
% Wat voor punt maken we hier? Dit moet een betere conclusie worden.

All these separate issues add up, eventually making the \textit{ptrace(2)} API
infeasible for big projects.

\section{Enter: Tracy}

We've tried to design Tracy to be as portable as possible - meaning that code
for ARM and x86 should be nearly (if not completely) the same. There are some
caveats \footnote{TODO see caveats section}; but some of these are simply not
fixable without extending the focus of Tracy to such an extent that it would no
longer be simply a library to trace and inject system calls.

Tracy elegantly works around most architecture specific issues and implements
functionality required to safely and efficiently trace programs on several
% FIXME: safely? Orly?
operating systems. (This includes fast memory read/write on Linux
and in the future safely tracing children on BSD)

Tracy introduces an API that allows a programmers to hook into specific system
calls, rather than every system call as is the case with ptrace.\footnote{Of
course, under the hood Tracy will handle every system call, whether the system
call is hooked or not.}
Tracy also has both a synchronous and asynchronous injection API (which
will be discussed in more detail later on) and tracy keeps track of the state of
a system call - if it is an event generated before a system call is executed; or
after a system call is executed.

It is often important to change arguments to a system call in a process that is
being traced; to safely change these additional hacks are required;
both changing the value directly as well as validating the value when the child
can still change the value are bad ideas.
The first interferes with the normal execution of the process
(although this may be exactly what the programmer wants) and the second is
sensitive to race conditions. A solution is presented in
\cite{Noordende_asecure}.

Tracy has functionality to allocate memory in the
tracee which itself cannot write but only read; thus allowing the controlling
process to copy arguments to that memory space, validate and change them as
necessary; finally change the pointer in the arguments to point to the memory
space and continue the system call as normal.

\chapter{Theory}

\section{Introduction to ptrace(2) and Tracy}

Several UNIX and UNIX-like systems support the \textbf{ptrace(2)} system call.
This system call allows one process to ``control'' another process - from now on
called \textit{tracee}, enabling the controlling process to stop and inspect
the \textit{tracee}, as well as writing to its memory. \textbf{ptrace(2)} is
mostly used by tools that aid debugging of software such as GDB\cite{} or
Valgrind \cite{}. \textbf{ptrace(2)} provides two ways of controlling a process
- either by controlling all the system calls made by the process or by stopping
the tracee after each instruction. The latter option has a serious effect on the
performance of the tracee.

Tracy is a library that uses \textbf{ptrace(2)} to trace the system calls of a
process. Tracy can inspect, modify and even inject system calls. Being able to
modify system calls gives the controlling process the ability to change
arguments of system calls before system calls are allowed - or even the ability
to ``deny'' system calls by changing the system call to a harmless one such as
\textbf{getpid(2)}. Obvious use cases for modifying system calls is a process
called ``sandboxing'' - intercepting and changing special system calls like
\textbf{open(2)} and prepend (if not already in place) a specific path to the
arguments such that the tracee cannot open files outside a specified path.
The same effect can be achieved using \textit{LD\_PRELOAD}. \footnote{fakeroot,
link} \textit{LD\_PRELOAD} however has serious limitations, it cannot attach to
already running processes and a process can\footnote{If written to do so} ignore
\textit{LD\_PRELOAD} all together.

\textbf{ptrace(2)} however, is very platform and operating system dependent,
the Tracy API strives to be platform and operating system independent by
applying architecture and operating system dependent hacks and fixes
``behind the scenes''.

\section{System call tracing, modification and injection}

\textbf{ptrace(2)} stops the tracee right before it executes a system call as
well as just after it has executed a system call.
While the controlling process is inspecting the tracee, the execution of the
tracee is paused. (Figure \ref{fig1})


\begin{figure}
\label{fig1}
\includegraphics[scale=0.6]{ptrace.png}
\caption{Ptrace control flow}
\end{figure}

This gives the controlling process the ability to read and modify registers,
which gives the controlling process the ability to do pretty much anything
with the tracee, including but not limited to:

\begin{itemize}
\item Modify the system call (number) that is executed.
\item Modify the arguments to system calls of the tracee.
\item Modify the instruction pointer (commonly called program counter), allowing
    the controlling process to resume the executing of the tracee at an entirely
    different set of instructions.
\item Inject system calls, by modifying the instruction pointer and changing the
    system call number.
\item Modify the return value from the system call.
\end{itemize}

\section{Memory access}

To fully be able to modify a tracee, the controlling process needs to be able to
read and write the tracee's memory. If the controlling process is to change
arguments that point to a specific page in the tracee's memory - like a string,
the controlling process needs to be able to write to the tracee's memory.

However, it is often not a good idea for the controlling process to change data
in a child. Instead, it would be a better idea to allocate a few pages in the
child and copy the data to those pages, change the argument to point to the new
pages and continue the system call. After the system call has completed, the
pages can be freed again. This way the child's original arguments are left
untouched, and for a reason: the child may re-use the buffers later on.

\section{Tracing children}

A tracee can spawn children by calling the fork()\footnote{among other system
calls: vfork, rfork, clone} system call. \textbf{ptrace(2)} does not
automatically trace children of a tracee. It is often useful to keep track of
all the children of a tracee. To do this, Linux supports specific
\textbf{ptrace(2)} options to trace the tree of children spawned by the tracee
as well. However, other platforms do not support these options and tracing
children of the tracee can be somewhat problematic.\footnote{strace does not
immediately trace children on non-Linux platforms:
\begin{quote}
    On non-Linux platforms the new process is attached to as soon as its pid is
    known (through the return value of fork(2) in the parent process).
    This means that such children may run uncontrolled for a while
    (especially in the case of a vfork(2)), until the parent is scheduled
    again to complete its (v)fork(2)  call.
\end{quote}
}

\begin{figure}
\label{fig2}
\includegraphics[scale=0.4]{ptrace2.png}
\caption{One system call with ptrace}
\end{figure}

We provide a solution to this problem in Tracy such that any children spawned
by the tracee will not run uncontrolled on any platform.

\chapter{Implementation}

\section{Tracing a process}

Tracing a process can be done in two different ways. A process can clone itself
and have the child announce that it wants to be traced and then execute a
process, or a process can attach to another running process.

\subsection{Fork and trace}

\subsection{Attaching}

%\begin{itemize}
%    \item The child can simply call ptrace(PTRACE\_TRACEME, 0, NULL, NULL);
%    \item A process can attach to an existing process using
%        ptrace(PTRACE\_ATTACH, pid, NULL, NULL);
%\end{itemize}

\section{System call tracing}

\section{System call modification}

\section{System call injection}

% sync & async injection

\section{Memory access}

% /proc/<pid>/mem
% (PEEK|POKE)USER

\section{Tracing children}

\subsection{Linux}

Linux 2.6 and onwards offer options to automatically trace all children
created by fork(2), vfork(2) and clone(2). Respectively:
PTRACE\_O\_TRACEVFORK, PTRACE\_O\_TRACEFORK, PTRACE\_O\_TRACECLONE.

% TODO: CLONE_UNTRACED vs PTRACE_O_TRACECLONE

\subsection{Safe execution of fork(2) and friends}

On operating systems that do not support the \textit{PTRACE\_O\_TRACE*} options,
another solution is required to ensure that all children are traced the moment
they are created. To achieve this, the fork(2)\footnote{and related} system call
must be executed in a controlled manner.

To implement this feature, we make use of system call injection as well as the
ability to be able to allocate and write to pages in the child. We allocate a
page in the child and write a few lines of assembly that will safely execute
fork(2) to the page. Once this is done, we deny the initial fork(2) call by
changing the system call to getpid(2). In the POST-getpid callback, we change
the Instruction Pointer (or Program Counter) to the first instruction in the
newly allocated page. Once the tracee starts executing the instructions in this
page, it will once again execute a system call - fork(2) in this case, and this
time we allow the call to proceed. However, after the fork(2) and we stored the
result of the call (pid), both the tracee and the child execute the rest of the
instructions in the page. The only other instructions in the page are a busy
while loop that calls the sched\_yield(2) system call. Now that both the tracee
and the child of the tracee are caught in this while loop.

At this moment, we are still only tracing the tracee, but we can now use the
``attach'' mechanism of ptrace to attach to the child of our tracee. Once we are
tracing the child of the tracee as well, we can restore the Instruction Pointer
(or Program Counter) to their original position (that is, just after the
original fork(2) call) and let both processes continue their execution.

% picture of the process

\subsection{Safe execution with different ABIs}

%

\subsection{Children with threads}

% Misschien verkeerde titel; maar dit zijn dingen waar we tegen aan liepen.
% En dingen waar we op moeten letten.
\section{Caveats}
%

\subsection{Clone on x86}

% Args switched...

\subsubsection{Clone on x64}

% Argument minder dan x86


% FIXME title sucks
\subsection{32 bit ABI on 64 bit}



\chapter{Soxy}

% socketcall x86 vs native syscalls on x64

\chapter{Future work}

\section{Threaded tracer}

% Threaded tracer. Why? Lots of tracee's doing lots of system calls
% may end up waiting on tracer. Solution: multiple threads that wait().

\section{Secure ABI mixing}

% Making sure that we catch all system calls made, even when ABIs are mixed
% (32 bit ABI on 64 bit, etc). This should be fixed in the Linux Kernel though.

\section{BSD Support}

% Arguments on stack.
% Needs safe-fork, but also with rfork(2).

\section{Memory sharing between tracer and tracee}

% Need to do some shm magic.

\section{Instant injection using signals}

% kill(2) with SIGTRAP and just do stuff.

%\textit{Netjes uitschrijven.}
%\begin{itemize}
%    \item Securing from mixed ABI using dynamic X\^W protection. (Including
%        picture)
%    \item Support more architectures and OSes.
%    \item Sharing memory between tracer and children using mapped files.
%    \item Instant injection of system calls using signals to stop the process.
%    \item Multithreaded tracing.
%    %\item Python bindings
%\end{itemize}

Applications
\begin{itemize}
    \item Buggy: Bug generation for application testing.
    \item Jelly: Secure Jail
    \item Fussy: User space fuse.
    \item Trippy: Visualising system calls using audio (and possibly video)
    \item Rippy: Ripping/dumping media streams.
    \item Dumpy: I/O dumping. (Like tcpdump)
    \item Loggy/stracy/dotty: System call logging/tracing/visualisation.
\end{itemize}


\chapter{Related work}

\section{strace}

% strace
% gdb
% jail?

\bibliography{report}

\end{document}
