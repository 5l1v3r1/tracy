\documentclass[a4paper, 10pt]{report}
%\documentclass[a4paper, twoside, 10pt]{report}
%\documentclass[a4paper, twoside, 10pt, twocolumn]{report}

\author{Jurriaan Bremer \and Merlijn Wajer \and Bas Weelinck}
\title{Tracy: UNIX system call tracing}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{appendix}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{color}
\usepackage[utf8]{inputenc}

\definecolor{MidnightBlue}{rgb}{0, 0, 0.95}
\lstset{language=C,
    showspaces=false,
    showstringspaces=false
    basicstyle=\ttfamily,
    stringstyle=\color{MidnightBlue}\ttfamily,
    emphstyle=\color{red}\bf
}

\begin{document}
\maketitle

\nocite{*}
\bibliographystyle{plain}

\begin{abstract}
    Tracy is a system call tracing framework implemented on top of the UNIX
    ptrace(2) system call.
    Tracy can trace, modify and inject system calls as well as perform memory
    allocation in the child, modify the memory of children and safely trace
    all (newly created) children of a process being traced.
\end{abstract}

\tableofcontents

% Probleemstelling / Motivatie
% Wat is er al?
% Hoe? Oplossing
% Implementatie / Toepassing / Illustratie
% Conclusie
% Referenties / Further Work
%
% XXX NOTES XXX
%
% PTRACE_TRACE_{FORK,VFORK,CLONE} is a mess. If we simply want to be called on
% clone() in case of a clone event, we must disable fork and vfork; otherwise it
% may also instead return fork or vfork events. From the man page:
%
% This  option  may not catch clone(2) calls in all cases.  If the tracee calls clone(2)
% with  the  CLONE_VFORK  flag,  PTRACE_EVENT_VFORK  will  be   delivered   instead   if
% PTRACE_O_TRACEVFORK  is set; otherwise if the tracee calls clone(2) with the exit sig‚Äê
% nal set to SIGCHLD, PTRACE_EVENT_FORK will be delivered if PTRACE_O_TRACEFORK is set.

% Gebruiken PTRACE_O_TRACESYSGOOD voor performance.

% execve(2) under ptrace:
% When one thread in a multithreaded process calls execve(2), the kernel destroys all other threads in
% the  process,  and  resets  the thread ID of the execing thread to the thread group ID (process ID).
% (Or, to put things another way, when a multithreaded process does an execve(2), at completion of the
% call,  it  appears  as though the execve(2) occurred in the thread group leader, regardless of which
% thread did the execve(2).)  This resetting of the thread ID looks very confusing to tracers:

% Misschien pre/post renamen naar syscall entry en exit?

% XXX END NOTES XXX

%
% ---- STUFF -----
% socketcall
% KISS
% Add SOCKS5 somewhere. (Probably related work)
% UDP in the current SOCKS5 protocol
% UDP over ssh ( :-( )
% sshfs ergens noemen?
% ---- STUFF -----

\chapter{Introduction}

% AANTREKKELIJKE OPENING
Programmers spend a rather large part of their time finding mistakes in their
computer programs. Programmers usually refer to this routine as debugging.
Programmers employ various tools to aid them in debugging programs.

Several kinds of debugging exist. The most common debugging method is
focussed around crashes in a program. Other types of debugging include
performance analysis and analysis of system calls performed by the program.
A system call is a method for a program to request a service from an operating
system's kernel. The kernel of an operating system is the main component
of most operating systems; it is a bridge between the hardware and programs.

% XXX: Nog niet helemaal klaar, hier weer iets meer over system calls en wat
% er allemaal mee gedaan wordt? Het nut van het tracen van system calls in
% debuggers, e.d.

Inspecting the system calls performed by a program is done programmatically
using the \textbf{ptrace} system call. A program inspecting the
% TODO: ptrace(2), ptrace, textbf{ptrace}, etc? Nu clarifyen?
system calls of another program is said be to be ``tracing'' the other
program. The program that is being traced is called the ``tracee'' and the
program tracing the ``tracee'' is called the ``tracer''.
Tracing is a limited definition in the sense that the term does not
mention the possibility to modify the program that is being traced.
Using \textbf{ptrace} the tracer can also modify the tracee, including
reading and writing to the memory of the tracee and changing the system calls
made by the tracee.

% AANLEIDING / MOTIVATIE

The ability to modify the program memory and system call allows for a great
variety of applications. A possible application is the so called ``jailing''
of programs - only allow system calls that satisfy certain requirements thus
restricting the access of a program to the system. Other applications are
transparently routing or inspecting all the network traffic of a program.

As previously stated, tracing programs is done using the \textbf{ptrace}
system call on UNIX systems. % Het is namelijk niet POSIX
Using ptrace directly to trace a program has several downsides: the ptrace
interface is not very programmer friendly. The interface is not standarised
\footnote{ptrace is not part of the POSIX standard} and ptrace is not
architecture agnostic, meaning a tracer requires architecture specific code.

% meteen inleiding naar de centrale vraag?
% xxx: lpd zit er nog niet in. willen we dat wel?


% Aanleiding / Motivatie:
% - Er zijn interessant praktische mogelijkheden: o.a. jailen en proxyfier.
% - De ptrace API is matig (WE GEBRUIKEN HEM WEL) en LD_PRELOAD is prutje


% DOELSTELLING
%
% Vergemakkelijken van het tracen van processen door middel van het leveren van
% een uniforme interface
%
% PROBLEEMSTELLING
%
% Adviserende vraagstelling.
%
% Adviserende:
% - Hoe kan system call tracing _beter_? (betere api e.d., maar je kan ptrace
%   niet echt wegwerken of grondig aanpassen)
%
% Centrale vraag
% - Hoe kan system call tracing worden verbeterd met betrekking tot API
%   transparantie voor kernel versie en architectuur op Linux?
%
% Deel vragen:
%   - Welk effect heeft de architectuur op het interpreteren van system calls?
%   - Welk effect heeft de architectuur op memory access?
%   - Welke problemen zijn er met de ptrace API.
%   - Wat voor effect heeft ptrace op de performance van programma's?
%   - 
%
% Opbouw
%

% When tracing a process $A$, another process $B$ is notified when a system call
% is made by process $A$  and then allows process $A$ to continue with its
% execution. An example of a program that traces system calls is
% \textit{strace}\cite{strace}.
% 
% Apart from \textit{tracing} system calls, it is also possible to
% \textit{change}
% (arguments of) system calls before they are executed. This allows for a range
% of other applications such as not allowing specific system calls and
% injecting system calls. Typically, the debugging api also allows reading and
% writing to the process being debugged.

% Some of the applications that can be realised with this particular feature set
% includes jailing programs, performance analysis tools and transparently
% redirecting input and output of a program, such as proxifying network
% traffic or virtualising filesystem access.
% 
% The debugger API on most UNIX operating systems is implemented using the
% \textit{ptrace} system call. A huge downside of ptrace is that ptrace
% has not been standardised and differs per platform and computer architecture.
% Other shortcomings of ptrace will be discussed later on.
% TODO: ^ Deze zin weglaten?

% One of the main reasons we created tracy was the lack of a proper library
% for system call interception amongst the popular UNIX-like systems with
% varying CPU architectures.
% 
% Tracy is a process tracing framework which uses ptrace but tries to provide
% an API that is mostly platform and computer architecture independent,
% allowing for much easier creation of cross platform tracing applications.
% 
% % XXX: While... while? :-(
% While it is not possible to create a completely platform independent API while
% not heavily reducing functionality, we strive to create a robust and powerful
% API to trace processes in a more platform independent way.
% 
% To demonstrate the system call interception, injection and modification
% we introduce Soxy (Chapter \ref{chapter:soxy}): an application to route network
% traffic through a SOCKS 5 proxy using tracy.

% Oplossing voor problemen zoals:
%   -   Jailing/Sandboxing
%   -   Debugging tools
%   -   Performance analysis tools
%   -   Transparent routing of lots of different things. (fuse in only userspace
%   for example, vpn, socks proxy)
%
%   Bestaande tools:
%   -   GDB, Valgrind
%   -   strace
%   -   tsocks (maar limited)

% Tracy can be used to create a wide variety of software, including
% \textit{Debugging tools}, \textit{Performance analysis tools}, \textit{Forensic
% tools}, \textit{Jailing and Sandboxing tools} and \textit{Transparent routing of
% data} (such as internet packets of user space filesystems).


% Hopelijk is dit iets meer wat Leen bedoelt. Wat secties hier onder moeten we
% omschrijven. Een beetje dubbel op informatie is geen probleem, daarvoor is het
% een inleiding.
% LD_PRELOAD is niet zo boeiend.
%

\section{Existing solutions and their problems}

There are several ways to transparently intercept calls to a library or
system calls. LD\_PRELOAD is one such method to intercept calls to a library.
This should not be confused with intercepting system calls; LD\_PRELOAD
cannot intercept system calls; this is a reason not to use LD\_PRELOAD.
% Raar stukje

\subsection{LD\_PRELOAD}

\textbf{LD\_PRELOAD} is a way to prioritize loading of certain libraries
while creating and loading a process.

One can use this to load a shared object (a library) into a process,
before any other libraries (such as glibc) are loaded;
this makes it possible to (transparently) override functions typically
provided by other libraries.

For our example, this ``injected'' library would provide its own
``recvfrom'' and ``sendto''\footnote{It should probably provide
a lot more functions; but the example will not benefit from naming others.};
and the program being run would instead call the functions provided by
this library.

One common proxyfier, \textbf{tsocks}, is an application that loads
other applications with their own library that overwrites specific
network functionality, thus allowing transparent network routing.

However, because LD\_PRELOAD relies on the dynamic loader and the fact that
programs have to make use of libraries, LD\_PRELOAD also has several downsides.

One of these downsides is that LD\_PRELOAD simply does not work on all
applications; some applications do not use the glibc methods and instead
perform system calls directly. Another way to ``escape'' from LD\_PRELOAD
is indeed to simply perform system calls in the program (using inline assembly
or even the \textit{syscall(2)} system call) rather than using
% XXX: syscall(2), is dat geen glibc functie? Ergo, kan je die niet wel afvangen
% met LD_PRELOAD
provided libraries such as glibc.

There are some upcoming languages that do not even use glibc at all - languages
like Go \cite{golang} talk to the kernel directly and thus perform their
system calls by calling the kernel directly instead of
relying on (g)libc functions which would in turn call the kernel.

LD\_PRELOAD is not a viable solution when one wants to transparently capture
all (specific) system calls of a process, independent on what kind of
userspace libraries the process uses.

\subsection{The ptrace(2) API}

\textbf{ptrace(2)} allows a process to catch all of the system calls (or even
step through every instruction, but we have no use for that in tracy)
made by another process (called the \textit{tracee}), which makes ptrace system
call tracing completely independent of user space helper libraries used by the
tracee. In other words, ptrace does not suffer from the same limitation as
LD\_PRELOAD.

ptrace has platform-specific extensions (to the API) and the
implementation differs per platform.
% FIXME: Wat voor extensions? (arm %setsyscall,etc)

% XXX: Dit hieronder is fout. We vangen wel alles af; maar we weten niet of
% het nummer 32 of 64 bit is.
To actually accurately catch every single system call made by a process one has
to perform all sorts of tricks\ref{secure-abi}, depending on the operating
system and architecture. Tracy currently does not implement all of these
tricks, but support is planned.

Aside from functional differences, there are also differences in ptrace
functionality.
For example, BSD supports reading or writing a big chunk of the memory
of the tracee at once using the ptrace API, while Linux only allows
reading or writing only one processor word at a time.
On the other hand, Linux has options to automatically trace
children created by the tracee where BSD lacks support for
this particular feature\footnote{Tracy will however support it on
BSD\ref{safe-fork}}.

Aside from the differences per operating system, there are also differences
regarding the cpu architecture, because every architecture has its own
instruction set.

Due to ptrace being a very low-level system call, which operates on assembly
level, it is not possible to simply ``change the return value'' of a system
call. Each instruction set has its own registers and on top of that, operating
systems often have different uses for each register.


% Dit is niet te veel detail, het is een realisatie van echte ptrace problemen
% en een goede inleiding naar de volgende alineas - namelijk dat ptrace niet
% geschikt is om direct te gebruiken en dat tracy veel beter is.
% XXX: Introduceren: Pre en Post system call event? Dit komt eerder niet
% XXX: voorbij.
One would have to find out what register this is on each platform,
keep track if the current event is a pre (entry)- or post(exit)-system
call event
\footnote{If the process is about to execute a system call or has just
executed a system call}, let alone
perform some extra architecture-specific calls to ensure that the result is
properly set\footnote{ARM requires extra changes to make the register
modification of a system call number persistent.}.

There is no way to hook into a specific system call, no way
to simply inject a system call, it is not simple to change values of some
variable/register in an architecture-agnostic way and it is not trivial
to allocate or change memory in a child.

Even though \textbf{ptrace(2)} provides all the functionality required to
trace and intercept system calls\footnote{Which is why tracy uses ptrace},
the functions provided by ptrace are very basic and only provide the
essential building blocks for tracing applications.
% Wat voor punt maken we hier? Dit moet een betere conclusie worden.

All these separate issues add up, eventually making the \textit{ptrace(2)} API
infeasible for large projects. % Ook raar; als ze tracy gebruiken gebruiken ze
% toch ook ptrace?

\section{Enter: Tracy}

We've tried to design tracy to be as portable as possible - meaning that code
for ARM and x86 should be nearly (if not completely) the same. There are some
caveats \footnote{TODO see caveats section}; but some of these are simply not
fixable without extending the focus of tracy to such an extent that it would no
longer be simply a library to trace and inject system calls.

Tracy elegantly works around most architecture specific issues and implements
functionality required to safely and efficiently trace programs on several
% FIXME: safely? Orly?
operating systems. (This includes fast memory read/write on Linux
and in the future safely tracing children on BSD)

Tracy introduces an API that allows a programmers to hook into specific system
calls, rather than every system call as is the case with ptrace.\footnote{Of
course, under the hood tracy will have to handle every system call, whether
the system call is hooked or not. We propose a fix to this problem in
Section \ref{ptrace-perf}} tracy also has both a synchronous and asynchronous
injection API (which will be discussed in more detail later on) and tracy keeps
track of the state of a system call - if it is an event generated before a
system call is executed; or after a system call is executed.

It is often important to change arguments to a system call in a process that is
being traced; to safely change these additional hacks are required;
both changing the value directly as well as validating the value when the child
can still change the value are bad ideas.
The first interferes with the normal execution of the process
(although this may be exactly what the programmer wants) and the second is
sensitive to race conditions. A solution is presented in
\cite{Noordende_asecure} and the feature in tracy is planned (Section
\ref{memory-share}).

Tracy has functionality to allocate memory in the
tracee which itself cannot write but only read; thus allowing the controlling
process to copy arguments to that memory space, validate and change them as
necessary; finally change the pointer in the arguments to point to the memory
space and continue the system call as normal.

\chapter{Theory}

\section{Introduction to ptrace(2) and Tracy}

Several UNIX and UNIX-like systems support the \textbf{ptrace(2)} system call.
This system call allows one process to ``control'' another process - from now on
called \textit{tracee}, enabling the controlling process to stop and inspect
the \textit{tracee}, as well as writing to its memory. \textbf{ptrace(2)} is
mostly used by tools that aid debugging of software such as GDB\cite{gdb}.
\textbf{ptrace(2)} provides two ways of controlling a process
- either by controlling all the system calls made by the process or by stopping
the tracee after each instruction. The latter option has a serious effect on the
performance of the tracee and is of no use to tracy.

Tracy is a library that uses \textbf{ptrace(2)} to trace the system calls of a
process. Tracy can inspect, modify and even inject system calls. Being able to
modify system calls gives the controlling process the ability to change
arguments of system calls before system calls are executed - or even the ability
to ``deny'' system calls by changing the system call to a harmless one such as
\textbf{getpid(2)}.

Obvious use cases for modifying system calls is a process
called ``sandboxing'' - intercepting and changing special system calls like
\textbf{open(2)} and prepend (if not already in place) a specific path to the
arguments such that the tracee cannot open files outside a specified path.
The same effect can be achieved using \textit{LD\_PRELOAD}. \footnote{fakeroot,
link}% XXX
\textit{LD\_PRELOAD} however has serious limitations, it cannot attach to
already running processes and a process can\footnote{If written to do so} work
around \textit{LD\_PRELOAD} all together, defeating the purpose of the sandbox.

However, \textbf{ptrace(2)} is very platform and operating system dependent,
the tracy API strives to be platform and operating system independent by
applying architecture and operating system dependent hacks and fixes
``behind the scenes''.

\section{System call tracing, modification and injection}

\textbf{ptrace(2)} stops the tracee right before it executes a system call as
well as just after the tracee has executed a system call. When the tracee
is stopped before a system call, we say that the tracee is in \textbf{pre}
system call state; if the system call has executed and the tracee has once again
been suspended we say that the tracee is in \textbf{post} system call state.
While the controlling process is inspecting the tracee, the execution of the
tracee is paused. (Figure \ref{fig1})


\begin{figure}
\label{fig1}
\includegraphics[scale=0.6]{ptrace.png}
\caption{Ptrace control flow}
\end{figure}

This gives the controlling process the ability to read and modify registers,
which gives the controlling process the ability to do pretty much anything
with the tracee, including:

\begin{itemize}
\item Modify the system call (number) that is executed.
\item Modify the arguments to system calls of the tracee.
\item Modify the instruction pointer (commonly called program counter), allowing
    the controlling process to resume the executing of the tracee at an entirely
    different set of instructions.
\item Inject system calls, by modifying the instruction pointer and changing the
    system call number.
\item Modify the return value of the system call.
\end{itemize}

\section{Memory access}

To be able to fully modify a tracee, the controlling process needs to be able to
read and write the tracee's memory. If the controlling process is to change
arguments that point to a specific page in the tracee's memory - like a string,
the controlling process needs to be able to write to the tracee's memory - or
share a small part of the controlling process' own memory with the tracee.

Changing the memory of the tracee is usually not a good idea, as that could
interfere with the tracee's execution.
Instead, it would be a better idea to allocate a few pages in the
child and copy the data to those pages, change the argument to point to the new
pages and continue the system call. After the system call has completed, the
pages can be freed again. This way the child's original arguments are left
untouched, and for a reason: the child may want to re-use the memory later on.

%TODO: Pages allocaten in child (wat voor beide RW is) is racy;
%zie future work memory sharing oplossing.

\section{Tracing children}

% XXX: Hier staat nog geen rfork() bij.
A tracee can spawn children by calling the \textbf{fork(2)}\footnote{among
    other system calls: vfork, rfork, clone} system call. \textbf{ptrace(2)}
does not automatically trace children of a tracee.

In certain occasions, one may want to trace all the children of a tracee.
To do this, Linux supports specific \textbf{ptrace(2)} options to trace
the tree of children spawned by the tracee as well.

However, other platforms do not support these options and tracing
children of the tracee can be somewhat problematic.\footnote{strace does not
immediately trace children on non-Linux platforms:
% Cite strace hier weer, man page citen? Waar komt de quote vandaan (man page)
\begin{quote}
    On non-Linux platforms the new process is attached to as soon as its pid is
    known (through the return value of fork(2) in the parent process).
    This means that such children may run uncontrolled for a while
    (especially in the case of a vfork(2)), until the parent is scheduled
    again to complete its (v)fork(2)  call.
\end{quote}
}

\begin{figure}
\label{fig2}
\includegraphics[scale=0.4]{ptrace2.png}
\caption{One system call with ptrace}
\end{figure}

We provide a solution to this problem in tracy such that any children spawned
by the tracee will not run uncontrolled on any platform in Section \ref{safe-fork}.

\chapter{Implementation}

\section{Tracing a process}

Tracing a process can be done in two different ways. A process can either attach
to another running process, or clone a clone of itself and consequently  use
ptrace() in the child to make the parent (the original process) trace the child
and then \textbf{execve(2)} another process.

\subsection{Fork and trace}

As explained in the previous section, the parent issues a \textbf{fork(2)} call.
The child then performs a \textbf{ptrace(2)} call, with the
\textit{PTRACE\_TRACEME} argument. The child then raises \textit{SIGTRAP};
because the child is being traced by its parent, the child is then suspended
until the parent performs a \textbf{wait(2)} followed by a call to ptrace to
continue the process with the \textit{PTRACE\_SYSCALL} argument to
\textbf{ptrace(2)}. The parent can inspect and change the child before it issues
the continue call. The code demonstrating this can be found in
Appendix \ref{appendix:createtrace}

\subsection{Attaching}

% TODO: How does one attach
%
% XXX: Noemen dat we attach ook gebruiken in safe-fork

\section{System call tracing}

% TODO: Mist nog wat diepte. Hoe krijgen we precies notifications? (waitpid)
% En wat voor signal (PTRACE_O_TRACESYSGOOD).
Tracing system calls with \textbf{ptrace(2)} is done by issuing ptrace on the
tracee with the \textit{PTRACE\_SYSCALL} option, this will make the tracee
suspend on entry (pre) and exit (post) of the next system call. Resuming a
suspended tracee is done with the same option. Tracy uses this option on
all the tracees.

Tracy keeps track of each child; it has to store information about the state
of the child: will the next stop be a system call entry or exit, or are we
currently injecting a system call? Aside from those two states, Tracy also
has to do some other internal bookkeeping.
% XXX: Bijvoorbeeld, suppress first SIGSTOP

% Meer is niet nodig denk ik, er staat ook een hoop in het event system.

\section{System call modification}

Modifying system calls can be done at two points: before and after the
system call is executed. Changing the system call ``after'' it has been executed
does not undo the effect of said system call, but it allows the tracer to change
result values of the system call.
\footnote{The tracer can of course change every register and the memory of the
tracee at any point when the tracee is suspended.}
Changing values before the system call is executed is more exciting, as it
allows the tracer to actually \textit{change} the system call. For example, by
modifying the register that stores the system call number, it is possible to
execute a completely different system call. This serves two purposes:
``denying'' system calls by changing the system call register to a harmless
system call such as getpid and ``injecting'' system calls by changing the
system call number and later on the instruction pointer.


% TODO: Tracy specifiek stuk hier? Methode namen hoeft niet, maar wellicht wel
% hoe wij het doen?

\section{Event system}
\label{event-system}

Tracy is uses event-based system to report on activities on a tracee. This is
particularly fitting as the \textbf{waitpid(2)} call blocks until an event
occurs. As a result of this tracy also blocks until a new event occurs.

Each signal and system call (pre and post) is an event.
The tracy function \textit{tracy\_wait\_event} waits for a action on
(a specific or) any child and returns a new tracy event. Aside from
events for signals and system calls, tracy also exposes another event; an
internal event which describes an internal tracy event; this event is required
for asynchronous injection and may be used for other features in the future.

\subsection{System call hooks}

Users of the tracy library can hook specific and even all system calls. For
each system call, the user provides a callback which will be called when
the related system call occurs. The callback is provided with full access to
event. The return value of the callback determines the action that tracy
will take. A callback for signals also exists as well a callback for each
system call that has not been hooked.

\section{System call injection}

Tracy supports injection system calls into any process that is being traced.

The injection of a system call is the process of executing a system call in
a specified tracee, without requiring said tracee to explicitly call the
system call.

Theoretically it is possible to inject a system call at any point during
the execution (as discussed in Section \ref{instant-inject}),
tracy however can only inject system calls in a pre and post
system call state. In other words, one can currently only inject system calls
when a tracee is stopped because it is currently trying to perform a system
call. Luckily, this is hardly an issue before this is always the case in a
tracy system call hook; they can only be called upon a system call of a tracee.

Transparent injection of system calls is not possible, in the most strict sense.
As most system calls indirectly affect the tracee (with the exception of system
calls like \textbf{getpid(2)} and \textbf{fstat(2)}), the tracee will usually
be left in a modified state. However, to perform system call injection as
transparently as possible, we ensured that the registers before the injection,
are identical to the registers after the injection.

Injecting system calls relies on that fact that the program counter (or
instruction pointer) of the tracee can be modified. If the length of the system
call instruction is known, it is possible to ``jump back'' to the system call
instruction. % TODO: Add figure with asm + int 0x80 and arrows.

The process of injecting a system call differs per system call state (pre or
post).

\begin{figure}
    \centering
    \subfloat[Injection from a pre state]{\label{fig:pre-inj}\includegraphics[width=0.4\textwidth]{pre.png}}
    \hspace{1em}
    \subfloat[Injection from a post state]{\label{fig:post-inj}\includegraphics[width=0.4\textwidth]{post.png}}
    \caption{Injection for pre and post system call states}
    \label{fig:injection}
\end{figure}

% TODO: Jump naar pre en post uitleg.

\subsection{Pre-syscall injection}

As seen in figure \ref{fig:pre-inj}

\subsection{Post-syscall injection}

As seen in figure \ref{fig:pre-inj}


\subsection{Asynchronous injection in Tracy}

Tracy supports asynchronous injection. Typically, when injecting a system call
in a tracee, tracy waits for the system call that is being injected to complete
and then restores the tracee to its previous state. This process can be split
into two stages, readying the tracee to perform a system call and restoring
the tracee to its original state. No system call returns instantly and it
may be favourable to perform other tasks rather than waiting for the system
call to complete.

Asynchronous injection is method to start the injection of a system call in
some process $A$, and then perform other tasks (such as injecting another
system call in another process $B$) instead of waiting for the system call
of $A$ to complete.
Once process $A$ has finished its (injected) system call, tracy will store
the return value and restore the process to its original state.

Functionally this makes no difference to the injection of a system call, but
it does allow tracy to handle the requests of other (suspended) processes
instead of simply waiting for process $A$ to finish.
% De performance boost is niet helemaal duidelijk. Ik wil responsive zeggen,m
% maar dat klinkt ook zo raar. XXX

It should be noted that while asynchronous injection is usually preferred,
synchronous injection is supported by tracy as well and used in tracy
internally where asynchronous injection simply isn't worth the extra work
and effort.

\section{Memory access}

% TODO: process_vm_{read,write}v noemen.

Any program that uses the \textbf{ptrace(2)} API will probably want to access the
traced process' memory as well. Reasons can range from simply dumping pointer
contents to monitoring, changing or even injecting new system calls with
completely stand-alone data. Furthermore, in case of IO intensive operation
this access should be fairly fast as well.

Unfortunately as with most functions ptrace provides, memory access standards
differ from operating system to operating system and are also
affected by architectural quirks. Tracy tries to hide these differences and
provide a uniform, fast way to access memory.

\subsection{On Linux}
On Linux tracy achieves fast memory access by employing a feature of the
``/proc'' filesystem that was designed to work in unison with
\textbf{ptrace(2)}.

The classical way of accessing child memory on Linux was through the
\textit{PTRACE\_PEEKDATA} and \textit{PTRACE\_POKEDATA} operations.
The downside of this method is its dependence on C's long type and the
amount of data that can be transferred.
These ptrace operations are used to respectively read and write individual
processor words.

% XXX: Hoezo weten we dat niet? Gewoon claimen of niet zeggen IMHO
On Linux the "long" type has, as far as we know, the same size as the
processor word size, so 32 bits on a 32-bit architecture and
64 bits on a 64-bit architecture.

This is where the trouble starts, not only is it not possible to simply read
or write single bytes of memory, whenever one wants to access say 4kb of
memory, depending on the architecture, this may require more than 1024
calls to ptrace. Needless to say the amount of time spent in context switches
and kernel code is enormous.
% XXX: Context switches, waar? Het child is suspended.

\subsubsection{Alternative: through /proc}
Linux provides another way to access memory of a process. The ``/proc''
filesystem, used by a lot of utilities to provide information about kernel
and process state can also be used to access arbitrary process memory,
given certain (security related) requirements are met.
Process information can usually be acquired by opening a folder
named ``/proc/$<pid>$'' where ``$<pid>$'' must be substituted with a process
identifier. In this folder several files, and folders, are contained which
provide information on things such as, threads, open files, memory maps and
memory contents.

The ``/proc/$<pid>$/mem'' file is the one used by tracy to access child memory.
Opening this file will present child memory as one contiguous file which
can be modified using the usual IO operations.
% Contigous lare? What are the usual operations? Elaborate

This also means we can now write single bytes of memory without the need
of first reading a processor word. We can now read 4kB of memory with a
single system call or any arbitrary amount of memory provided we can allocate
a large enough buffer to contain the data.

% XXX: Wat
Obviously, one does not simply open the ``/proc/$<pid>$/mem'' file of any
arbitrary process as this would cause a major security issue. The only
processes capable of successfully opening this file are either processes
tracing the target process, or super-user processes.

% XXX: Future work, memory mapped child access?
% /proc/<pid>/mem
% (PEEK|POKE)USER

\section{Signals}

Tracy obtains information about the signals directly from the
\textbf{waitpid(2)} call. The waitpid call has an argument called
\textit{status} which contains the information about the signal that was
received. Retrieving the signal sent to the tracee is done using the
\textbf{WSTOPSIG} macro. \\

To pass a signal to a tracee, tracy passes the signal number as data
argument to the ptrace \textit{PTRACE\_SYSCALL} api call. This will
resume the execution of the tracee with said signal. If the data is
left at zero, no signal will be delivered. This makes it possible to
suppress certain signals by simply not passing them along to the tracee.

% We could also talk about PTRACE_O_TRACEEXEC and PTRACE_O_TRACEVFORKDONE
% and PTRACE_O_TRACEEXIT

\subsection{Caveats}

When the feature to automatically trace newly created children in Linux
is turned on, every new child will initially be send a \textit{SIGSTOP}
signal. For this reason, tracy suppresses the first SIGSTOP that is sent
to a newly create tracee if the automatically trace option is enabled.

\section{Tracing children}

% TODO: This can't be empty

\subsection{Linux}

Linux 2.6 and onwards offer options to automatically trace all children
created by \textbf{fork(2)}, \textbf{vfork(2)} and \textbf{clone(2)}.
Respectively: \textit{PTRACE\_O\_TRACEVFORK}, \textit{PTRACE\_O\_TRACEFORK},
\textit{PTRACE\_O\_TRACECLONE}.

% TODO: CLONE_UNTRACED vs PTRACE_O_TRACECLONE

% XXX: Friends?
\subsection{Safe execution of fork(2) and friends}
\label{safe-fork}

On operating systems that do not support the \textit{PTRACE\_O\_TRACE*} options,
another solution is required to ensure that all children are traced the moment
they are created. To achieve this, the \textbf{fork(2)}
\footnote{and related: vfork, clone} system call must be executed in a
controlled manner.

To implement this feature, we make use of system call injection as well as the
ability to be able to allocate and write to pages in the child. We allocate a
page in the child and write a few lines of assembly that will safely execute
\textbf{fork(2)} to the page. Once this is done, we deny the initial
\textbf{fork(2)} call by changing the system call to \textbf{getpid(2)}.
In the POST-getpid callback, we change the Instruction Pointer
(or Program Counter) to the first instruction in the newly allocated page.
Once the tracee starts executing the instructions in this
page, it will once again execute a system call - \textbf{fork(2)} in this case,
and this time we allow the call to proceed. However, after the \textbf{fork(2)}
and we stored the result of the call (pid), both the tracee and the child
execute the rest of the instructions in the page. The only other instructions
in the page are a busy while loop that calls the \textbf{sched\_yield(2)}
system call. Now that both the tracee and the child of the tracee are caught
in this while loop.

At this moment, we are still only tracing the tracee, but we can now use the
``attach'' mechanism of ptrace to attach to the child of our tracee. Once we are
tracing the child of the tracee as well, we can restore the Instruction Pointer
(or Program Counter) to their original position (that is, just after the
original \textbf{fork(2)} call) and let both processes continue their execution.

% picture of the process. Just use dot.

% Assembly hier includen?
% Signals e.d. hier noemen? Hoe we die gebruiken voor het verkrijgen van het pid
% bij vfork.

%

\subsection{Children with threads}

% Hoe werkt resource sharing? CLONE_VM, CLONE_FILES, unshare(2), etc.

% Introductie naar threads. Wat beschrijft een thread nu?


% Threads op Linux zijn processes die bepaalde resources sharen (CLONE_VM,
% CLONE_FILES).

% Waar wordt aangegeven wat ze delen? Hoe kan je dingen ``on delen''? (unshare)

% Hoe kan je in Tracy threads detecteren? (TID group, etc)

\section{Performance in ptrace(2)}
\label{ptrace-perf-problems}

When a tracee performs a lot of system calls, the overhead of \textbf{ptrace(2)}
becomes very noticeable. The main issue is that for every system call the kernel
has to perform four context switches. The first one is suspending the tracee
and replacing the tracee with the tracer (tracy), then tracy issues a few
(at least two) system calls, the kernel resumes the tracee (another context
switch); once the system call of the tracee is completed, the tracee is
suspended again and the tracer takes over (context switch number three),
again performing at least two ptrace system calls and finally the tracee
is resumed again (context switch number four). This entire process is
repeated for every system call, be it the inexpensive \textbf{read(2)}
system call or the fairly expensive \textbf{clone(2)} system call, they're
all a lot slower for the tracee due to this overhead of suspending and
resuming the tracee. The main issue here is that \textbf{ptrace(2)} does
not allow the reporting of specific system calls only - the tracer has
to handle every single system call event, even if the tracer will take no
other action than resume the tracee on most of the system calls.

We present a (theoretical) solution to this problem in
Section \ref{ptrace-perf}.

% Misschien verkeerde titel; maar dit zijn dingen waar we tegen aan liepen.
% En dingen waar we op moeten letten.
\section{Caveats}

% TODO Dit mag niet leeg zijn.

\subsection{Clone(2)}

The Linux specific \textbf{clone(2)} system call is a bit problematic, for
several reasons. The clone system call interface differs per architecture;
on x86 clone has one argument extra compared to AMD64; and Linux on x86
also \textit{switches} two registers
\footnote{This can be observed in \textit{arch/x86/kernel/entry\_32.S}
and \textit{arch/x86/kernel/process.c}}.

 % XXX: Welke ook alweer

% x86: Args switched... Waarom? Misschien wel leuk om uit te zoeken.
% x64: Argument minder dan x86

\subsection{vfork}

% Problemen die we tegen kwamen met vfork? (Geen?)

% FIXME title sucks
\subsection{32 bit ABI on 64 bit}

As of yet, tracy does not support running 32 bit tracees with a 64 bit
tracy instance.
% XXX TODO

% Future work entry. Willen we het hier ook nog? (Ja, kort)

% Hoe detect je de mode? Dat is het probleem.
% Beetje hetzelfde als Safe execution with diff ABIs


\chapter{Soxy}
\label{chapter:soxy}

In order to show the power and features of tracy, as well as finding bugs and
improving the API, we have developed Soxy, a proxifier \footnote{An
application which tunnels internet traffic through another server} on top of
tracy which works solely on existing binaries (that is, executables which do
not provide such functionality natively.)

Soxy has the unique ability to tunnel all (or a subset of) the network traffic
created by a process (either a child processes or a running processes) over a
proxy based on the SOCKS5 \footnote{\href{http://www.ietf.org/rfc/rfc1928.txt}
{RFC 1928 - SOCKS5 Protocol}} protocol.

The server which will be used as proxy server must be configured to accept and
tunnel SOCKS5 data. There are several proxy daemons available, including
\verb=ssh=.

\section{Python bindings}

% socketcall x86 vs native syscalls on x64 in caveats

Besides Soxy, which demonstrates an example usage of the tracy library, we
also provide Python bindings, allowing rapid development of applications
which utilize tracy. As a matter of facts, Soxy has been implemented using the
Python bindings, ensuring the correctness and efficiency of these bindings.

The Python bindings provide a similar, but even easier, API for using tracy.

For example, a pre-syscall hook on \textit{write} which duplicates the write
system call (i.e. write the same string twice) looks like the following.

\begin{lstlisting}[language=Python]
def hook_write(child, event, args):
    if child.pre:
        child.inject(args.syscall, args)
\end{lstlisting}

\section{Soxy Internals}

\subsection{SOCKS5}

Complete documentation of the SOCKS5 algorithm can be found in
RFC 1928 \footnote{\href{http://www.ietf.org/rfc/rfc1928.txt}
{RFC 1928 - SOCKS5 Protocol}}. The global flow for TCP connections
is as follows.

\begin{itemize}
\item Application connects to the Proxy Server
\item Optionally the application performs some sort of authentication
\item A request containing the destination address is sent
\item Server replies with success or failure
\item Proxy connection has been established
\end{itemize}

After the proxy connection has been established, the protocol does not need
any further work, because all incoming and outgoing traffic goes through the
proxy server.

\subsection{Implementation}

Soxy implements the SOCKS5 protocol as follows, using hooks on the
\textit{socket} and \textit{connect} system calls. When a
socket is created, using the socket system call, Soxy determines whether the
socket is TCP or UDP based. Following, when the socket attempts to connect to
another machine, using the connect system call, Soxy injects a few system
calls in order to connect to the proxy server, authenticate, and establish the
proxy connection.

\subsection{Asynchronous Sockets}

\subsection{Proxifying UDP Traffic}

\chapter{Future work}

\section{Threaded tracer}

As the number of tracees for a single tracy instance increases, the
likelyhood of tracy becoming a bottleneck increases. Since tracy is
single threaded, it is very possible a lot of tracees will have to wait
on tracy to perform a system call. \\

We believe that it is possible to add multithreading support to tracy where
each thread can perform its own \textbf{waitpid(2)}. Access to certain
datastructures in tracy will have to be guarded with semaphores, but
we think multithreading will be both viable to program and an effective
wait to increase the performance of tracy with a lot of tracees.

\section{Secure ABI mixing}
\label{secure-abi}


% TODO: integrate https://en.wikipedia.org/wiki/W%5EX
% link to AMD ?
% link to arm? explain oabi and eabi?
% Explain ABI (before this chapter?)
On some platforms such as AMD64 and ARM Linux implements several ABIs.
These ABIs are sometimes invoked differently (as is the case with AMD64)
and it is not easy to tell what ABI is being used to issue the system call.
The problem here is that each ABI (sometimes) has different system call
numbers, which means that \textbf{read(2)} on AMD64 ABI is not the same
as the 32 bit ABI on the AMD64 platform. Tracy currently always assumes
a x86\_64 ABI. This is not just a functional issue (not being able to
properly identify a 32 bit ABI system call) but a security problem because it
allows any tracee to ``fake'' tracy into thinking it is doing system call $A$
where it is in fact doing system call $B$; tracy will not call the proper hook
function and (if told to do so) may deny the wrong system call or even worse,
not deny the system call at all. \\

In a sense not being able to identify the system call ABI can be seen as a
limitation of the Linux \textbf{ptrace(2)} API. It should be possible to
integrate support for identifying the system call ABI in the Linux kernel
by using a system that is already in place: the \textit{PTRACE\_O\_TRACESYSGOOD}
extension. If \textit{PTRACE\_O\_TRACESYSGOOD} is enabled, the kernal sets bit 7
of the signal being delivered to the tracer; this makes it easier to distinguish
between a normal \textit{SIGTRAP} signal and a trap caused by a system call of
a tracee. The kernel could expose (and set) another bit (or more) which would
indicate the ABI of the current system call.

However, a kernel change is not an immediate solution and would require all
users of tracy to install a very recent Linux kernel or even apply a patch
to their current kernel. \\

Another solution to the problem of identifying the ABI of the current
system call would be to read the current assembly instruction. AMD64 uses a
different instruction to perform a system call than the 32 bit ABI; which
means we can use that instruction to differentiate the two ABIs. There are a
few caveats however: it is possible that the instruction in the program (memory)
and the instruction in the cpu pipeline are not the same; a program could use
another thread to intentionally wipe out or change the instruction that was
used to invoke the system call, which would result in tracy reading a faulty
or fake instruction. \\

To prevent another thread in the process to change the instruction we can
use the \textbf{mprotect(2)} system call to mark the memory as read and execute
only (not writable), which would make it impossible to change the contents of
the memory without calling \textbf{mprotect(2)} to mark the memory as writable.
Calling \textbf{mprotect(2)} from a tracee will however be noticed by tracy,
upon which tracy can take appropriate actions (such as allow the memory to be
written but mark it read and execute only after the write has occurred and make
sure the cpu pipeline has is flushed by calling jmp).

One could even go as far as cache the system call instructions of each tracee
so they do not have to be read again until a tracee changes its own
instructions.

Even though now yet supporting identifying the ABIs is a serious security issue,
it is also mainly important when someone wants to be completely sure that every
single system call is traced. Most programs also do not usually modify their
own instructions; nor do they create their own instructions (JITs do)
% XXX: JIT reference, Java is jit, ofc, firefox js etc
that perform 32 bit system calls in a 64 bit process.

\section{BSD Support}

Support for Tracy on the BSD variants is planned, but will require some
additional work. We have not extensively examined \textbf{ptrace(2)} and
system calls in general on BSD variants, but a few things jumped out. \\

BSD uses \textbf{rfork(2)} instead of \textbf{clone(2)} and BSD also does
not support automatically tracing processes created by a tracee. While
we can emulate this effectively with tracy's safe fork
Section(\ref{safe-fork}) it will still require some work.

Apart from this functional difference, there is also a difference in
how BSD variants treat the system call arguments. Arguments of a system
call are pushed onto the stack (the last parameter is pushed first).
\cite{int80h}

Alternatively, if Linux emulation is enabled, BSD variants (at least FreeBSD)
also support the Linux way of system calls, by passing the arguments in
registers in the same manner as Linux.

BSD also returns errors differently than Linux (although again, it supports
Linux emulation). BSD sets the ``carry flag'' upon failure, whereas Linux
returns a negative value upon error.

\section{Memory sharing between tracer and tracee}
\label{memory-share}

% Need to do some shm magic.

\section{Instant injection using signals}
\label{instant-inject}

An interesting addition to tracy would be the ability to inject a system call
even when a tracee is not performing a system call: that is, when the tracee
is not stopped. We can simply stop the tracee by sending it a signal will
\textbf{kill(2)}; which will automatically suspend the tracee as
\textbf{ptrace(2)} gives us complete control over the tracee.
So, before the signal is actually received by the tracee, we have control
over the tracee and we can resume it later while suppressing the signal that
should never be delivered as we only send the signal to suspend the tracee and
gain control.

Once the tracee is suspended, we can jump to some previously crafted assembly
similar to our safe fork code (Section \ref{safe-fork}), and execute a system
call by simply invoking the system call instruction and modifying the
arguments and system call instruction in tracy. Once the system call
has completed we can store the return code and jump back to the original code,
and the finally resume the tracee.

The process just described can also be used to inject system calls
in the signal hook exposed by tracy.

While it would not be too hard to implement support for this particular
feature, we have postponed the feature due to time constraints. We also
did not find the feature particularly useful because tracy is event based,
which means that in most cases the tracee is already stopped.

% XXX: Dit kan onhandig zijn in combinatie met threaded tracing. Wat als
% we een signal sturen en een andere thread die afvangt?


%\textit{Netjes uitschrijven.}
%\begin{itemize}
%    \item Securing from mixed ABI using dynamic X\^W protection. (Including
%        picture)
%    \item Support more architectures and OSes.
%    \item Sharing memory between tracer and children using mapped files.
%    \item Instant injection of system calls using signals to stop the process.
%    \item Multithreaded tracing.
%    %\item Python bindings
%\end{itemize}

\section{Calling functions in the tracee}

\section{Tracing 32 bit applications with a 64 bit tracer}

\section{Improving ptrace(2) performance}
\label{ptrace-perf}

As previously discussed in Section \ref{ptrace-perf-problems}, the overhead
of \textbf{ptrace(2)} is very noticeable when a tracee performs a lot of
small and inexpensive system calls - they suddenly become very expensive.

The problem boils down to the fact that \textbf{ptrace(2)} currently
has no mechanism which allows the tracer to only get notified on specific
system calls, so that other system calls can execute without requiring
intervention from the tracer.

It then follows that this performance
issue can be solved by adding such an API to the Linux kernel. \\
% TODO: We kunnen SECCOMP referencen.

We wrote a simple Linux kernel patch (against Linux 3.4) to demonstrate
our claim and we also added experimental support for this feature to tracy.

However, the patch is incomplete and lacks features such as support for
multiple ABIs (Section \ref{secure-abi}). \\

The API is very basic and allows one to add (and delete) specific system
calls to a list. This list can then either function as a whitelist or a
blacklist, in other words, the Linux kernel either notifies the tracer of
all the system calls in the list, or notifies the tracer of all system calls
but the system calls in the list.

% TODO: API verder beschrijven?

Because tracy is aware of the all the system calls that are hooked by the
program using tracy, tracy can make informed decisions about system calls
that do not need to be received - as they would never result in a hook in
the event system (Section \ref{event-system}) being executed.

Unless tracy uses this particular system call internally, tracy could decide
to advice the kernel to not notify tracy of in the event that this particular
system call is executed.

% TODO: Patch in appendix?


%Applications
%\begin{itemize}
%    \item Buggy: Bug generation for application testing.
%    \item Jelly: Secure Jail
%    \item Fussy: User space fuse.
%    \item Trippy: Visualising system calls using audio (and possibly video)
%    \item Rippy: Ripping/dumping media streams.
%    \item Dumpy: I/O dumping. (Like tcpdump)
%    \item Loggy/stracy/dotty: System call logging/tracing/visualisation.
%\end{itemize}


% \chapter{Related work}
% 
% \section{strace}

% strace
% gdb
% jail?
% ltrace? (is niet ptrace based)


% Discussie is re-capture van alles weg gezegd hebben
\chapter{Discussion}

% Performance sectie / chapter ergens?
% Viability

\bibliography{report}

\pagebreak

\appendix
\addappheadtotoc

\chapter{Creating and tracing a process}
\label{appendix:createtrace}

% XXX: Willen we hier failsafes in?
\begin{lstlisting}
    pid = fork();

    /* Child */
    if (pid == 0) {
        r = ptrace(PTRACE_TRACEME, 0, NULL, NULL);
        if (r) {
            fprintf(stderr, "PTRACE_TRACEME failed.\n");
            _exit(1);
        }

        raise(SIGTRAP);

        execve(...);

        /* ... */
    }

    if (pid == -1)
        return NULL;

    waitpid(pid, &status, __WALL);
    signal_id = WSTOPSIG(status);
    if (signal_id != SIGTRAP) {
        return NULL;
    }

    /* Resume child and tell ptrace to stop at the next system call */
    r = ptrace(PTRACE_SYSCALL, pid, NULL, 0);
\end{lstlisting}



\end{document}
