\documentclass[a4paper, twoside, 10pt, twocolumn]{report}

\author{Jurriaan Bremer \and Merlijn Wajer \and Bas Weelinck}
\title{Tracy: Making ptrace(2) fun} % TODO TITLE

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}

\begin{document}
\maketitle

\begin{abstract}
    Tracy is a system call tracing framework implemented on top of the POSIX
    ptrace(2) system call.
    Tracy can, apare from tracing system calls, modify and inject system calls
    as well as perform several other useful tasks such as memory allocation in
    the child, modifying the memory of childs and safely trace all
    (newly created) children of a process being traced.
\end{abstract}

\tableofcontents


\chapter{Theory}

\section{Introduction to ptrace(2) and Tracy}

Several UNIX and UNIX-like systems support the \textbf{ptrace(2)} system call.
This system call allows one process to ``control'' another process - from now on
called \textit{tracee}, enabling the controlling process to stop and inspect
the \textit{tracee}, as well as writing to its memory. \textbf{ptrace(2)} is
mostly used by tools that aid debugging of software such as gdb\cite{} or
valgrind \cite{}. \textbf{ptrace(2)} provides two ways of controlling a process
- either by controlling all the system calls made by the process or by stopping
the tracee after each instruction. The latter option has a serious effect on the
performance of the tracee.

Tracy is a library that uses \textbf{ptrace(2)} to trace the system calls of a
process. Tracy can inspect, modify and even inject system calls. Being able to
modify system calls gives the controlling process the ability to change
arguments of system calls before system calls are allowed - or even the ability
to ``deny'' system calls by changing the system call to a harmless one such as
\textbf{getpid(2)}. Obvious uses cases for modifying system calls is a process
calling ``sandboxing'' - intercepting and changing special system calls like
\textbf{open(2)} and prepend (if not already in place) a specific path to the
arguments such that the tracee cannot open files outside a the specified path.
The same effect can be achieved using \textit{LD\_PRELOAD}. \footnote{fakeroot,
link} \textit{LD\_PRELOAD} however has serious limitations, it cannot attach to
already running processes and a process can\footnote{If written to do so} ignore
\textit{LD\_PRELOAD} all together.

\textbf{ptrace(2)} however, is very platform and operating system dependant,
the Tracy API tries to be platform and operating system by applying architecture
and operating system dependant hacks and fixes ``behind the scenes''.

\section{System call tracing, modification and injection}

\textbf{ptrace(2)} stops the tracee right before it executes a system call as
well as just after it has executed a system call.
While the controlling process is inspecting the tracee, the execution of the
tracee is paused. (Figure \ref{fig1})


\begin{figure}
\label{fig1}
\includegraphics[scale=0.6]{ptrace.png}
\caption{Ptrace control flow}
\end{figure}

This gives the controlling process the ability to read and modify registers,
which gives the controlling process the ability to do pretty much anything
with the tracee, including but not limited to:

\begin{itemize}
\item Modify the system call (number) that is executed.
\item Modify the arguments to system calls of the tracee.
\item Modify the instruction pointer (commonly called program counter), allowing
    the controlling process to resume the executing of the tracee at an entirely
    different set of instructions.
\item Inject system calls, by modifying the instruction pointer and changing the
    system call number.
\end{itemize}

\section{Memory access}

To fully be able to modify a tracee, the controlling process needs to be able to
read and write the tracee memory. If the controlling process is to change
arguments that point to a specific page in the tracee's memory - like a string,
the controlling process needs to be able to write to the tracee's memory.

However, it is often not a good idea for the controlling process to change data
in a child. Instead, it would be a better idea to allocated a few pages in the
child and copy the data to those pages, change the argument to point to the new
pages and continue the system call. After the system call is complete, the pages
can be freed again. This way the child's original arguments are left untouched.

\section{Tracing children}

A tracee can spawn children by calling the fork()\footnote{among other system
calls: vfork, rfork, clone} system call. \textbf{ptrace(2)} does not
automatically trace children of a tracee. It is often useful to keep track of
all the children of a tracee. To do this, Linux supports specific
\textbf{ptrace(2)} options to trace the tree of children spawned by the tracee
as well. However, other platforms do not support these options and tracing
children of the tracee can be somewhat problematic.\footnote{strace does not
immediately trace children on non-Linux platforms:
\begin{quote}
    On non-Linux platforms the new process is attached to as soon as its pid is
    known (through the return value of fork(2) in the parent process).
    This means that such children may run uncontrolled for a while
    (especially in the case of a vfork(2)), until the parent is scheduled
    again to complete its (v)fork(2)  call.
\end{quote}
}

\begin{figure}
\label{fig2}
\includegraphics[scale=0.4]{ptrace2.png}
\caption{One system call with ptrace}
\end{figure}

We provide a solution to this problem in Tracy such that any children spawned
by the tracee will not run uncontrolled on any platform.

\chapter{Implementation}

\section{System call tracing}

% sync & async tracing

\section{System call modification}

\section{System call injection}

\section{Memory access}

% /proc/<pid>/mem
% (PEEK|POKE)USER

\section{Tracing children}

\subsection{Linux}

Linux 2.6 and onwards offer options to automatically trace all children
created by fork(2), vfork(2) and clone(2). Respectively:
PTRACE\_O\_TRACEVFORK, PTRACE\_O\_TRACEFORK, PTRACE\_O\_TRACECLONE.

% TODO: CLONE_UNTRACED vs PTRACE_O_TRACECLONE


\subsection{Safe execution of fork(2) and friends}

On operating systems that do not support the \textit{PTRACE\_O\_TRACE*} options,
another solution is required to ensure that all children are traced the moment
they are created. To achieve this, the fork(2)\footnote{and related} system call
must be executed in a controlled manner.

To implement this feature, we make use of system call injection as well as the
ability to be able to allocate and write to pages in the child. We allocate a
page in the child and write a few lines of assembly that will safely execute
fork(2) to the page. Once this is done, we deny the initial fork(2) call by
changing the system call to getpid(2). In the POST-getpid callback, we change
the Instruction Pointer (or Program Counter) to the first instruction in the
newly allocated page. Once the tracee starts executing the instructions in this
page, it will once again execute a system call - fork(2) in this case, and this
time we allow the call to proceed. However, after the fork(2) and we stored the
result of the call (pid), both the tracee and the child execute the rest of the
instructions in the page. The only other instructions in the page are a busy
while loop that calls the sched\_yield(2) system call. Now that both the tracee
and the child of the tracee are caught in this while loop.

At this moment, we are still only tracing the tracee, but we can now use the
``attach'' mechanism of ptrace to attach to the child of our tracee. Once we are
tracing the child of the tracee as well, we can restore the Instruction Pointer
(or Program Counter) to their original position (that is, just after the
original fork(2) call) and let both processes continue their execution.

% picture of the process

\chapter{Soxy}

\chapter{Related work}

\section{strace}

% strace
% jail?

\end{document}
